<h1>
Inheritance
</h1>

<div>
Любая функция в js может выступать в качестве <strong>конструктора</strong>,
если вызывается с ключевым словом new.
</div>

<div>
Конструктор создает новый объект,
при это this(из тела функции-конструктора) начинает ссылаться на этот самый объект(созданный).
Методы и свойства описанные в функции-конструкторе через this становяться методами и свойствами объекта.

```

function Parent(name, age) { this.name = name; this.age = age;};

let childNew = new Parent('Petr', 22);

childNew => {name: "Petr", age: 22}

childNew instanceof Parent
```

Через оператор instanceof можно проверить является ли функция конструктором.

<br/>

<h2>
Тезисно
</h2>
<ul>
<li>
У каждого объекта есть скрытое свойство [[Prototype]]
(Исходя из спецификации языка, ссылка на прототип объекта [[prototype]] не обязана быть доступной для чтения и изменения, но во многих браузерах __proto__ ссылка на скрытое свойство).
</li>
<li>
Любая функция может быть конструктором и имеет свойство prototype,
в которое можно передать объект который станет прототипом ([[Prototype]]) вновь создаваемого через конструктор объекта
В случае отсутствия инициализирующих параметров в конструкторе, скобки можно опускать (let child = new Parent).
</li>
<li>
Прототипом объекта будет или объект(на основе которого создан объект) или null если вверх по цепочке таких объектов не осталось.
Запрашиваемые у объекта свойства и методы будут во вторую очередь искаться в прототипе через описанную ссылку.
</li>
<li>
У любого объекта есть свойство Constructor, это ссылка на функцию которая выступила конструктором созданного объекта.
</li>
</ul>

<br/>

<div>

```

let sample = {age: 10, fullInfo: function(){console.log(this.age + this.name)}};
let Const = function(name){this.name = name;};

Const.prototype = sample;

let child = new Const('Ivan');

child.fullInfo(); => 10Ivan
```
</div>

</div>